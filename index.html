<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>It's a Dog's Life - Topdown Prototype</title>
    <style>
      :root {
        color-scheme: dark;
      }

      *,
      *::before,
      *::after {
        box-sizing: border-box;
      }

      html,
      body {
        margin: 0;
        padding: 0;
        height: 100%;
        overflow: hidden;
        font-family: "Avenir Next", "Segoe UI", system-ui, sans-serif;
        background: radial-gradient(circle at top, #86c5ff 0%, #112035 65%);
      }

      canvas {
        display: block;
        width: 100vw;
        height: 100vh;
      }

      #ui {
        position: fixed;
        inset: 0;
        display: flex;
        flex-direction: column;
        justify-content: space-between;
        pointer-events: none;
      }

      #title {
        margin: 1.5rem auto 0;
        padding: 0.75rem 1.5rem;
        border-radius: 999px;
        background: rgba(7, 11, 19, 0.55);
        color: #f7fbff;
        font-size: clamp(1rem, 2vw, 1.3rem);
        letter-spacing: 0.08em;
        text-transform: uppercase;
        box-shadow: 0 1.5rem 3rem rgba(0, 0, 0, 0.35);
      }

      #loadError {
        margin: 0.75rem auto 0;
        padding: 0.85rem 1.4rem;
        border-radius: 1rem;
        background: rgba(180, 32, 44, 0.85);
        color: #fff8f8;
        font-size: 0.95rem;
        letter-spacing: 0.015em;
        max-width: min(34rem, 90vw);
        text-align: center;
        opacity: 0;
        transform: translateY(-8px);
        transition: opacity 0.25s ease, transform 0.25s ease;
        pointer-events: none;
      }

      #loadError.visible {
        opacity: 1;
        transform: translateY(0);
      }

      #prompt {
        align-self: center;
        margin-bottom: 2rem;
        padding: 0.85rem 1.65rem;
        border-radius: 0.95rem;
        background: rgba(7, 11, 19, 0.7);
        color: #f4f7fb;
        font-size: 0.95rem;
        letter-spacing: 0.04em;
        transform: translateY(10px);
        opacity: 0;
        transition: opacity 0.2s ease, transform 0.25s ease;
      }

      #prompt.visible {
        opacity: 1;
        transform: translateY(0);
      }

      #messagePanel {
        position: fixed;
        bottom: 3rem;
        left: 50%;
        max-width: min(32rem, 90vw);
        transform: translate(-50%, 10px);
        padding: 1rem 1.5rem;
        border-radius: 1.1rem;
        background: rgba(12, 15, 24, 0.92);
        color: #f6f7fb;
        box-shadow: 0 1.5rem 3rem rgba(0, 0, 0, 0.45);
        font-size: 1.05rem;
        line-height: 1.45;
        letter-spacing: 0.015em;
        opacity: 0;
        transition: opacity 0.3s ease, transform 0.3s ease;
        pointer-events: none;
      }

      #messagePanel.visible {
        opacity: 1;
        transform: translate(-50%, 0);
      }

      #messagePanel h2 {
        margin: 0 0 0.4rem;
        font-size: 1.15rem;
        letter-spacing: 0.06em;
        text-transform: uppercase;
        color: #ffd166;
      }

      #messagePanel p {
        margin: 0;
        white-space: pre-line;
      }

      #musicToggle {
        position: fixed;
        top: 1.5rem;
        right: 1.5rem;
        padding: 0.6rem 1.2rem;
        border: none;
        border-radius: 999px;
        background: rgba(7, 11, 19, 0.75);
        color: #f7fbff;
        font-size: 0.9rem;
        letter-spacing: 0.05em;
        text-transform: uppercase;
        cursor: pointer;
        box-shadow: 0 1.25rem 2.5rem rgba(0, 0, 0, 0.35);
        transition: background 0.2s ease, transform 0.2s ease;
      }

      #musicToggle:hover {
        background: rgba(12, 18, 30, 0.85);
        transform: translateY(-2px);
      }
    </style>
    <script type="importmap">
      {
        "imports": {
          "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
          "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
      }
    </script>
  </head>
  <body>
    <canvas id="scene"></canvas>
    <div id="ui">
      <div id="title">It's a Dog's Life &mdash; Showgrounds Prototype</div>
      <div id="loadError"></div>
      <div id="prompt"></div>
    </div>
    <button id="musicToggle" type="button">Mute Music</button>
    <div id="messagePanel">
      <h2></h2>
      <p></p>
    </div>

    <script type="module">
      import * as THREE from "three";

      const canvas = document.getElementById("scene");
      const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      renderer.shadowMap.enabled = true;

      const scene = new THREE.Scene();
      scene.background = new THREE.Color(0x7fc8f8);

      const aspect = window.innerWidth / window.innerHeight;
      const viewSize = 80;
      const camera = new THREE.OrthographicCamera(
        -viewSize * aspect,
        viewSize * aspect,
        viewSize,
        -viewSize,
        0.1,
        500
      );
      const cameraHeight = 120;
      camera.position.set(0, cameraHeight, 0);
      camera.lookAt(0, 0, 0);

      const hemi = new THREE.HemisphereLight(0xf9f9ff, 0x28432f, 0.85);
      scene.add(hemi);

      const sun = new THREE.DirectionalLight(0xffffff, 0.85);
      sun.position.set(80, 150, 60);
      sun.castShadow = true;
      sun.shadow.mapSize.set(2048, 2048);
      sun.shadow.camera.left = -150;
      sun.shadow.camera.right = 150;
      sun.shadow.camera.top = 150;
      sun.shadow.camera.bottom = -150;
      sun.shadow.camera.updateProjectionMatrix();
      scene.add(sun);

      const prompt = document.getElementById("prompt");
      const messagePanel = document.getElementById("messagePanel");
      const messageTitle = messagePanel.querySelector("h2");
      const messageBody = messagePanel.querySelector("p");
      const musicToggle = document.getElementById("musicToggle");

      const spriteCanvas = document.createElement("canvas");
      spriteCanvas.width = 64;
      spriteCanvas.height = 64;
      const spriteCtx = spriteCanvas.getContext("2d");

      const handlerTexture = new THREE.CanvasTexture(spriteCanvas);
      handlerTexture.magFilter = THREE.NearestFilter;
      handlerTexture.minFilter = THREE.NearestFilter;
      handlerTexture.generateMipmaps = false;

      const spriteSheet = new Image();
      spriteSheet.crossOrigin = "anonymous";
      spriteSheet.src = "https://raw.githubusercontent.com/harry0957-oss/itsadogslife/main/assets/walk.png";

      let spriteLoaded = false;
      spriteSheet.addEventListener("load", () => {
        spriteLoaded = true;
        setSpriteFrame(currentFrame, directionRows[currentDirection]);
      });

      const handlerMaterial = new THREE.MeshBasicMaterial({
        map: handlerTexture,
        transparent: true,
        side: THREE.DoubleSide
      });

      const handler = new THREE.Group();
      const handlerSprite = new THREE.Mesh(new THREE.PlaneGeometry(14, 18), handlerMaterial);
      handlerSprite.rotation.x = -Math.PI / 2;
      handlerSprite.position.y = 0.4;
      handler.add(handlerSprite);
      scene.add(handler);

      const textureLoader = new THREE.TextureLoader();
      textureLoader.setCrossOrigin("anonymous");

      const tileMaterialCache = new Map();
      const surfaceGrid = [];
      const houseColliders = [];
      const signEntries = [];

      const loadError = document.getElementById("loadError");

      const mapState = {
        tileWorldSize: 4,
        width: 0,
        height: 0,
        minX: -80,
        maxX: 80,
        minZ: -80,
        maxZ: 80,
        bounds: { minX: -70, maxX: 70, minZ: -70, maxZ: 70 },
        spawnPosition: new THREE.Vector3(0, 0, 0),
        tileToWorld(col, row, y = 0) {
          const x = this.minX + this.tileWorldSize * col + this.tileWorldSize * 0.5;
          const z = this.maxZ - this.tileWorldSize * row - this.tileWorldSize * 0.5;
          return new THREE.Vector3(x, y, z);
        },
        worldToTile(x, z) {
          const col = Math.floor((x - this.minX) / this.tileWorldSize);
          const row = Math.floor((this.maxZ - z) / this.tileWorldSize);
          return { col, row };
        }
      };

      const buildingPalette = [
        { color: 0xfef3c7, trimColor: 0x1d3557, roofColor: 0xb56576 },
        { color: 0xe0f2ff, trimColor: 0x264653, roofColor: 0x457b9d },
        { color: 0xfdecef, trimColor: 0x2a9d8f, roofColor: 0xe76f51 },
        { color: 0xfff4e6, trimColor: 0x6d597a, roofColor: 0xb56576 },
        { color: 0xf0fff1, trimColor: 0x355070, roofColor: 0x6d597a },
        { color: 0xe9f5db, trimColor: 0x1f3c88, roofColor: 0x577590 }
      ];

      function createHouse({ color, trimColor, roofColor }) {
        const group = new THREE.Group();

        const base = new THREE.Mesh(
          new THREE.BoxGeometry(22, 16, 20),
          new THREE.MeshLambertMaterial({ color })
        );
        base.position.y = 8;
        base.castShadow = true;
        base.receiveShadow = true;
        group.add(base);

        const roof = new THREE.Mesh(
          new THREE.ConeGeometry(18, 10, 4),
          new THREE.MeshLambertMaterial({ color: roofColor })
        );
        roof.position.y = 18;
        roof.rotation.y = Math.PI / 4;
        roof.castShadow = true;
        group.add(roof);

        const door = new THREE.Mesh(
          new THREE.BoxGeometry(5, 8, 1.4),
          new THREE.MeshLambertMaterial({ color: trimColor })
        );
        door.position.set(0, 4, 10.7);
        door.castShadow = true;
        group.add(door);

        const windowGeometry = new THREE.BoxGeometry(4, 4, 1.2);
        const windowMaterial = new THREE.MeshLambertMaterial({ color: 0xf1f6ff });
        const windowPositions = [
          [-8, 6, 10.4],
          [8, 6, 10.4]
        ];
        windowPositions.forEach(([x, y, z]) => {
          const window = new THREE.Mesh(windowGeometry, windowMaterial);
          window.position.set(x, y, z);
          window.castShadow = true;
          group.add(window);
        });

        return group;
      }

      function createSign() {
        const group = new THREE.Group();

        const post = new THREE.Mesh(
          new THREE.CylinderGeometry(0.9, 1.1, 12, 12),
          new THREE.MeshLambertMaterial({ color: 0x8c5627 })
        );
        post.position.y = 6;
        post.castShadow = true;
        group.add(post);

        const plank = new THREE.Mesh(
          new THREE.BoxGeometry(9, 4.2, 1.1),
          new THREE.MeshLambertMaterial({ color: 0xfff5b5 })
        );
        plank.position.set(0, 10, 0.4);
        plank.castShadow = true;
        group.add(plank);

        return group;
      }

      function showPrompt(text) {
        prompt.textContent = text;
        prompt.classList.add("visible");
      }

      function hidePrompt() {
        prompt.classList.remove("visible");
        prompt.textContent = "";
      }

      let hideTimeout = null;
      function showMessage({ title, description }) {
        messageTitle.textContent = title;
        messageBody.textContent = description;
        messagePanel.classList.add("visible");
        clearTimeout(hideTimeout);
        hideTimeout = setTimeout(() => hideMessage(), 5000);
      }

      function hideMessage() {
        messagePanel.classList.remove("visible");
        messageTitle.textContent = "";
        messageBody.textContent = "";
        clearTimeout(hideTimeout);
      }

      const pressedKeys = new Set();
      let preferredAxis = "vertical";
      canvas.addEventListener("click", initializeAudio);
      window.addEventListener("pointerdown", initializeAudio, { once: true });

      window.addEventListener("keydown", (event) => {
        pressedKeys.add(event.code);
        if (event.code === "Enter" && currentSign) {
          showMessage(currentSign);
        }
        if (event.code === "Escape") {
          hideMessage();
        }
      });

      window.addEventListener("keyup", (event) => {
        pressedKeys.delete(event.code);
      });

      const directionRows = {
        up: 0,
        right: 3,
        down: 2,
        left: 1
      };
      let currentDirection = "down";
      let currentFrame = 0;
      const frameDuration = 0.12;
      let frameTimer = 0;

      function setSpriteFrame(frameIndex, directionRow) {
        if (!spriteLoaded) return;
        spriteCtx.clearRect(0, 0, 64, 64);
        spriteCtx.drawImage(
          spriteSheet,
          frameIndex * 64,
          directionRow * 64,
          64,
          64,
          0,
          0,
          64,
          64
        );
        handlerTexture.needsUpdate = true;
      }

      function updateDirection(direction) {
        if (currentDirection === direction) return;
        currentDirection = direction;
        setSpriteFrame(currentFrame, directionRows[currentDirection]);
      }

      function updateSpriteAnimation(delta, moving) {
        const row = directionRows[currentDirection];
        if (moving) {
          frameTimer += delta;
          if (frameTimer >= frameDuration) {
            frameTimer -= frameDuration;
            currentFrame = (currentFrame + 1) % 9;
            setSpriteFrame(currentFrame, row);
          }
        } else if (currentFrame !== 0) {
          currentFrame = 0;
          frameTimer = 0;
          setSpriteFrame(currentFrame, row);
        }
      }

      const movementVector = new THREE.Vector3();
      const clock = new THREE.Clock();
      const speed = 28;

      function determineSurface(position) {
        if (!surfaceGrid.length) return "grass";
        const col = Math.floor((position.x - mapState.minX) / mapState.tileWorldSize);
        const row = Math.floor((mapState.maxZ - position.z) / mapState.tileWorldSize);
        if (row < 0 || row >= surfaceGrid.length) return "grass";
        if (col < 0 || col >= surfaceGrid[row].length) return "grass";
        return surfaceGrid[row][col] || "grass";
      }

      function updateMovement(delta) {
        let inputX = 0;
        let inputZ = 0;
        if (pressedKeys.has("ArrowUp") || pressedKeys.has("KeyW")) inputZ -= 1;
        if (pressedKeys.has("ArrowDown") || pressedKeys.has("KeyS")) inputZ += 1;
        if (pressedKeys.has("ArrowLeft") || pressedKeys.has("KeyA")) inputX -= 1;
        if (pressedKeys.has("ArrowRight") || pressedKeys.has("KeyD")) inputX += 1;

        if (inputX !== 0 && inputZ !== 0) {
          if (preferredAxis === "horizontal") {
            inputZ = 0;
          } else {
            inputX = 0;
          }
        } else if (inputX !== 0) {
          preferredAxis = "horizontal";
        } else if (inputZ !== 0) {
          preferredAxis = "vertical";
        }

        const moving = inputX !== 0 || inputZ !== 0;

        if (moving) {
          if (Math.abs(inputX) > Math.abs(inputZ)) {
            updateDirection(inputX > 0 ? "right" : "left");
          } else {
            updateDirection(inputZ > 0 ? "down" : "up");
          }

          const length = Math.hypot(inputX, inputZ) || 1;
          movementVector
            .set(inputX / length, 0, inputZ / length)
            .multiplyScalar(speed * delta);

          let nextX = handler.position.x + movementVector.x;
          let nextZ = handler.position.z + movementVector.z;

          const { minX, maxX, minZ, maxZ } = mapState.bounds;
          nextX = THREE.MathUtils.clamp(nextX, minX, maxX);
          nextZ = THREE.MathUtils.clamp(nextZ, minZ, maxZ);

          for (const collider of houseColliders) {
            const withinZ = Math.abs(handler.position.z - collider.center.y) < collider.halfZ;
            if (withinZ && Math.abs(nextX - collider.center.x) < collider.halfX) {
              if (nextX > handler.position.x) {
                nextX = collider.center.x - collider.halfX;
              } else if (nextX < handler.position.x) {
                nextX = collider.center.x + collider.halfX;
              } else {
                nextX = handler.position.x;
              }
            }
          }

          for (const collider of houseColliders) {
            const withinX = Math.abs(nextX - collider.center.x) < collider.halfX;
            if (withinX && Math.abs(nextZ - collider.center.y) < collider.halfZ) {
              if (nextZ > handler.position.z) {
                nextZ = collider.center.y - collider.halfZ;
              } else if (nextZ < handler.position.z) {
                nextZ = collider.center.y + collider.halfZ;
              } else {
                nextZ = handler.position.z;
              }
            }
          }

          handler.position.x = THREE.MathUtils.clamp(nextX, minX, maxX);
          handler.position.z = THREE.MathUtils.clamp(nextZ, minZ, maxZ);

          const surface = determineSurface(handler.position);
          playFootsteps(surface);
        } else {
          stopFootsteps();
        }

        updateSpriteAnimation(delta, moving);
      }

      let currentSign = null;
      function updateInteraction() {
        let closest = null;
        let minDistance = Infinity;
        signEntries.forEach((sign) => {
          const distance = handler.position.distanceTo(sign.mesh.position);
          if (distance < minDistance) {
            minDistance = distance;
            closest = sign;
          }
        });

        const interactDistance = 22;
        if (closest && minDistance < interactDistance) {
          currentSign = closest;
          showPrompt(`Press Enter to read the ${closest.title} sign`);
        } else {
          currentSign = null;
          hidePrompt();
        }
      }
      const backgroundMusic = new Audio(
        "https://raw.githubusercontent.com/harry0957-oss/itsadogslife/main/assets/music/mapmusic.mp3"
      );
      const grassFootsteps = new Audio(
        "https://raw.githubusercontent.com/harry0957-oss/itsadogslife/main/assets/sounds/grasswalk.mp3"
      );
      const pathFootsteps = new Audio(
        "https://raw.githubusercontent.com/harry0957-oss/itsadogslife/main/assets/sounds/pathwalk.mp3"
      );

      let audioInitialized = false;
      let activeFootsteps = null;
      let musicMuted = false;

      function updateMusicToggleLabel() {
        musicToggle.textContent = musicMuted ? "Unmute Music" : "Mute Music";
      }

      musicToggle.addEventListener("click", (event) => {
        event.stopPropagation();
        musicMuted = !musicMuted;
        if (!audioInitialized) {
          initializeAudio();
        }
        backgroundMusic.muted = musicMuted;
        updateMusicToggleLabel();
      });

      updateMusicToggleLabel();

      
      function primeFootstep(audio) {
        audio.loop = true;
        audio.play().then(() => {
          audio.pause();
          audio.currentTime = 0;
        }).catch(() => {});
      }

      function initializeAudio() {
        if (audioInitialized) return;
        audioInitialized = true;

        backgroundMusic.preload = "auto";
        backgroundMusic.loop = true;
        backgroundMusic.volume = 0.2;
        backgroundMusic.muted = musicMuted;
        backgroundMusic.play().catch(() => {});

        grassFootsteps.preload = "auto";
        grassFootsteps.volume = 0.4;
        grassFootsteps.playbackRate = 1.5;
        grassFootsteps.loop = true;

        pathFootsteps.preload = "auto";
        pathFootsteps.volume = 0.5;
        pathFootsteps.loop = true;

        primeFootstep(grassFootsteps);
        primeFootstep(pathFootsteps);
      }

      function playFootsteps(surface) {
        if (!audioInitialized) return;
        const target = surface === "path" ? pathFootsteps : grassFootsteps;
        if (activeFootsteps && activeFootsteps !== target) {
          activeFootsteps.pause();
          activeFootsteps.currentTime = 0;
        }

        activeFootsteps = target;
        if (activeFootsteps.paused) {
          activeFootsteps.play().catch(() => {});
        }
      }

      function stopFootsteps() {
        if (!audioInitialized) return;
        if (activeFootsteps) {
          activeFootsteps.pause();
          activeFootsteps.currentTime = 0;
          activeFootsteps = null;
        }
      }

      async function loadLevel(url) {
        const resolved = new URL(url, import.meta.url);
        let fetchError = null;

        if (resolved.protocol !== "file:") {
          try {
            const response = await fetch(resolved.href, { cache: "no-store" });
            if (!response.ok) {
              throw new Error(`Failed to load level: ${response.status} ${response.statusText}`);
            }
            const data = await response.json();
            return data;
          } catch (error) {
            fetchError = error;
          }
        }

        if (resolved.protocol === "file:" || fetchError) {
          try {
            const module = await import(resolved.href, { assert: { type: "json" } });
            return module.default;
          } catch (importError) {
            if (fetchError) {
              throw fetchError;
            }
            throw importError;
          }
        }

        throw new Error(`Failed to resolve level from ${resolved.href}`);
      }

      async function buildLevel(url) {
        const data = await loadLevel(url);

        const tileWorldSize = data.tileWorldSize ?? data.tileSize ?? 32;
        const width = data.width ?? 0;
        const height = data.height ?? 0;
        const halfWidth = (width * tileWorldSize) / 2;
        const halfHeight = (height * tileWorldSize) / 2;

        mapState.tileWorldSize = tileWorldSize;
        mapState.width = width;
        mapState.height = height;
        mapState.minX = -halfWidth;
        mapState.maxX = halfWidth;
        mapState.minZ = -halfHeight;
        mapState.maxZ = halfHeight;
        mapState.bounds = {
          minX: mapState.minX + tileWorldSize * 0.5,
          maxX: mapState.maxX - tileWorldSize * 0.5,
          minZ: mapState.minZ + tileWorldSize * 0.5,
          maxZ: mapState.maxZ - tileWorldSize * 0.5
        };

        surfaceGrid.length = height;
        for (let row = 0; row < height; row++) {
          surfaceGrid[row] = new Array(width).fill("grass");
        }

        const tilesetEntries = Object.entries(data.tilesets ?? {});
        const tilesets = {};
        await Promise.all(
          tilesetEntries.map(
            ([key, info]) =>
              new Promise((resolve, reject) => {
                textureLoader.load(
                  info.src,
                  (texture) => {
                    texture.magFilter = THREE.NearestFilter;
                    texture.minFilter = THREE.NearestFilter;
                    texture.generateMipmaps = false;
                    texture.colorSpace = THREE.SRGBColorSpace;
                    const tileSize = info.tileSize ?? data.tileSize ?? 32;
                    const columns = Math.max(1, Math.floor(texture.image.width / tileSize));
                    const rows = Math.max(1, Math.floor(texture.image.height / tileSize));
                    tilesets[key] = { texture, tileSize, columns, rows, name: key };
                    resolve();
                  },
                  undefined,
                  (error) => reject(error)
                );
              })
          )
        );

        const layers = data.layers ?? [];
        const layerRoot = new THREE.Group();
        scene.add(layerRoot);

        const legend = data.legend ?? {};

        layers.forEach((layer, layerIndex) => {
          const group = new THREE.Group();
          group.position.y = layerIndex * 0.01;
          layerRoot.add(group);

          const grid = layer.grid ?? [];
          for (let row = 0; row < height; row++) {
            const rowData = grid[row] ?? [];
            for (let col = 0; col < width; col++) {
              const key = rowData[col];
              if (!key) continue;
              const tileDef = legend[key];
              if (!tileDef) continue;
              const tileset = tilesets[tileDef.tileset];
              if (!tileset) continue;

              const mesh = createTileMesh({ tileset, tileDef, col, row });
              mesh.position.y = 0;
              group.add(mesh);

              if (tileDef.surface) {
                surfaceGrid[row][col] = tileDef.surface;
              }
            }
          }
        });

        const spawnDef = data.objects?.spawn ?? data.spawn;
        if (spawnDef?.tile) {
          const spawn = mapState.tileToWorld(spawnDef.tile[0], spawnDef.tile[1]);
          if (spawnDef.offset) {
            spawn.add(
              new THREE.Vector3(
                spawnDef.offset[0] ?? 0,
                spawnDef.offset[1] ?? 0,
                spawnDef.offset[2] ?? 0
              )
            );
          }
          mapState.spawnPosition = spawn;
        }

        return data;
      }

      function createTileMesh({ tileset, tileDef, col, row }) {
        const geometry = new THREE.PlaneGeometry(mapState.tileWorldSize, mapState.tileWorldSize);
        geometry.attributes.uv = geometry.attributes.uv.clone();

        const tileIndex = tileDef.index ?? null;
        const frame = tileDef.frame ?? null;
        let column = 0;
        let tileRow = 0;
        if (frame) {
          column = frame[0];
          tileRow = frame[1];
        } else if (tileIndex !== null) {
          column = tileIndex % tileset.columns;
          tileRow = Math.floor(tileIndex / tileset.columns);
        }

        const du = 1 / tileset.columns;
        const dv = 1 / tileset.rows;
        const u0 = column * du;
        const v0 = 1 - (tileRow + 1) * dv;
        const uv = geometry.attributes.uv;
        for (let i = 0; i < uv.count; i++) {
          const u = uv.getX(i);
          const v = uv.getY(i);
          uv.setXY(i, u0 + u * du, v0 + v * dv);
        }
        uv.needsUpdate = true;

        const cacheKey = `${tileset.name}:${column},${tileRow}`;
        let material = tileMaterialCache.get(cacheKey);
        if (!material) {
          material = new THREE.MeshLambertMaterial({ map: tileset.texture, transparent: true });
          tileMaterialCache.set(cacheKey, material);
        }

        const mesh = new THREE.Mesh(geometry, material);
        mesh.rotation.x = -Math.PI / 2;
        mesh.receiveShadow = true;
        const worldPosition = mapState.tileToWorld(col, row);
        mesh.position.set(worldPosition.x, 0, worldPosition.z);
        return mesh;
      }

      function setupBuildings(levelData) {
        const buildings = levelData.objects?.buildings ?? [];
        buildings.forEach((data, index) => {
          const worldPosition = mapState.tileToWorld(data.tile[0], data.tile[1]);
          if (data.offset) {
            worldPosition.add(
              new THREE.Vector3(
                data.offset[0] ?? 0,
                data.offset[1] ?? 0,
                data.offset[2] ?? 0
              )
            );
          }

          if (data.spawnHouse !== false) {
            const palette = buildingPalette[index % buildingPalette.length];
            const house = createHouse(palette);
            house.position.copy(worldPosition);
            if (data.rotation) {
              house.rotation.y = THREE.MathUtils.degToRad(data.rotation);
            }
            scene.add(house);

            const halfSize = data.collider?.halfSize ?? [13, 12];
            const offset = data.collider?.offset ?? [0, 0];
            houseColliders.push({
              center: new THREE.Vector2(worldPosition.x + (offset[0] ?? 0), worldPosition.z + (offset[1] ?? 0)),
              halfX: halfSize[0],
              halfZ: halfSize[1]
            });
          } else if (data.collider) {
            const halfSize = data.collider.halfSize ?? [13, 12];
            const offset = data.collider.offset ?? [0, 0];
            houseColliders.push({
              center: new THREE.Vector2(worldPosition.x + (offset[0] ?? 0), worldPosition.z + (offset[1] ?? 0)),
              halfX: halfSize[0],
              halfZ: halfSize[1]
            });
          }

          const sign = createSign();
          const signOffset = data.signOffset ?? [0, 0, 6];
          sign.position.set(
            worldPosition.x + (signOffset[0] ?? 0),
            (signOffset[1] ?? 0),
            worldPosition.z + (signOffset[2] ?? 0)
          );
          if (data.signRotation) {
            sign.rotation.y = THREE.MathUtils.degToRad(data.signRotation);
          }
          scene.add(sign);

          signEntries.push({
            mesh: sign,
            title: data.title,
            description: data.description
          });
        });

        const extraSigns = levelData.objects?.extraSigns ?? [];
        extraSigns.forEach((data) => {
          const worldPosition = mapState.tileToWorld(data.tile[0], data.tile[1]);
          if (data.offset) {
            worldPosition.add(
              new THREE.Vector3(
                data.offset[0] ?? 0,
                data.offset[1] ?? 0,
                data.offset[2] ?? 0
              )
            );
          }
          const sign = createSign();
          const offset = data.signOffset ?? [0, 0, 0];
          sign.position.set(
            worldPosition.x + (offset[0] ?? 0),
            (offset[1] ?? 0),
            worldPosition.z + (offset[2] ?? 0)
          );
          if (data.signRotation) {
            sign.rotation.y = THREE.MathUtils.degToRad(data.signRotation);
          }
          scene.add(sign);
          signEntries.push({
            mesh: sign,
            title: data.title,
            description: data.description
          });
        });
      }

      function setupShowring(levelData) {
        const showring = levelData.objects?.showring;
        if (!showring?.tile) return;
        const center = mapState.tileToWorld(showring.tile[0], showring.tile[1]);
        const radius = showring.radius ?? 18;
        const floorRadius = showring.floorRadius ?? radius - 1.5;
        const height = showring.height ?? 1.4;

        const ringBorder = new THREE.Mesh(
          new THREE.CylinderGeometry(radius, radius, height, 64, 1, true),
          new THREE.MeshLambertMaterial({ color: 0x3a2c1f, side: THREE.DoubleSide })
        );
        ringBorder.position.set(center.x, height / 2, center.z);
        ringBorder.castShadow = true;
        ringBorder.receiveShadow = true;
        scene.add(ringBorder);

        const ringFloor = new THREE.Mesh(
          new THREE.CircleGeometry(floorRadius, 48),
          new THREE.MeshLambertMaterial({ color: 0xd9c097 })
        );
        ringFloor.rotation.x = -Math.PI / 2;
        ringFloor.position.set(center.x, 0.05, center.z);
        ringFloor.receiveShadow = true;
        scene.add(ringFloor);

        const bleacherMaterial = new THREE.MeshLambertMaterial({ color: 0xe6e0d6 });
        const bleacherRadius = radius + 6;
        for (let i = 0; i < 4; i++) {
          const bench = new THREE.Mesh(new THREE.BoxGeometry(12, 2, 4), bleacherMaterial);
          const angle = (i / 4) * Math.PI * 2;
          bench.position.set(
            center.x + Math.cos(angle) * bleacherRadius,
            1,
            center.z + Math.sin(angle) * bleacherRadius
          );
          bench.rotation.y = angle + Math.PI / 2;
          bench.castShadow = true;
          bench.receiveShadow = true;
          scene.add(bench);
        }
      }

      function scatterShrubs(count = 28) {
        const shrubMaterial = new THREE.MeshLambertMaterial({ color: 0x1e6f3b });
        const candidates = [];
        for (let row = 0; row < surfaceGrid.length; row++) {
          for (let col = 0; col < surfaceGrid[row].length; col++) {
            if (surfaceGrid[row][col] === "grass") {
              candidates.push({ row, col });
            }
          }
        }

        for (let i = 0; i < count && candidates.length > 0; i++) {
          const index = Math.floor(Math.random() * candidates.length);
          const { row, col } = candidates.splice(index, 1)[0];
          const center = mapState.tileToWorld(col, row);
          const shrub = new THREE.Mesh(
            new THREE.SphereGeometry(THREE.MathUtils.randFloat(2, 4), 12, 12),
            shrubMaterial
          );
          shrub.position.set(
            center.x + THREE.MathUtils.randFloatSpread(mapState.tileWorldSize * 0.6),
            THREE.MathUtils.randFloat(1, 3),
            center.z + THREE.MathUtils.randFloatSpread(mapState.tileWorldSize * 0.6)
          );
          shrub.castShadow = true;
          shrub.receiveShadow = true;
          scene.add(shrub);
        }
      }
 
        const LEVEL_URL =
        "https://raw.githubusercontent.com/harry0957-oss/itsadogslife/main/levels/emeraldisle.json";

      async function initializeLevel() {
        try {
          loadError.textContent = "";
          loadError.classList.remove("visible");

          const data = await buildLevel(LEVEL_URL);
          setupBuildings(data);
          setupShowring(data);
          scatterShrubs();
          handler.position.copy(mapState.spawnPosition);
          animate();
        } catch (error) {
          console.error(error);
          const advice =
            window.location.protocol === "file:"
              ? "Try running a local web server (for example: npx serve) so the browser can load JSON files."
              : "Please check that the level file exists and that your internet connection is available.";
          loadError.textContent = `Level failed to load. ${advice}`;
          loadError.classList.add("visible");
          animate();
        }
      }

      function animate() {
        requestAnimationFrame(animate);
        const delta = clock.getDelta();
        updateMovement(delta);
        updateInteraction();

        camera.position.set(handler.position.x, cameraHeight, handler.position.z);
        camera.lookAt(handler.position.x, handler.position.y, handler.position.z);

        renderer.render(scene, camera);
      }

      function handleResize() {
        const aspectRatio = window.innerWidth / window.innerHeight;
        camera.left = -viewSize * aspectRatio;
        camera.right = viewSize * aspectRatio;
        camera.top = viewSize;
        camera.bottom = -viewSize;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      }

      window.addEventListener("resize", handleResize);
      handleResize();

      initializeLevel();
    </script>
  </body>
</html>
