<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>It's a Dog's Life - Topdown Prototype</title>
    <style>
      :root {
        color-scheme: dark;
      }

      *,
      *::before,
      *::after {
        box-sizing: border-box;
      }

      html,
      body {
        margin: 0;
        padding: 0;
        height: 100%;
        overflow: hidden;
        font-family: "Avenir Next", "Segoe UI", system-ui, sans-serif;
        background: radial-gradient(circle at top, #86c5ff 0%, #112035 65%);
      }

      canvas {
        display: block;
        width: 100vw;
        height: 100vh;
      }

      #ui {
        position: fixed;
        inset: 0;
        display: flex;
        flex-direction: column;
        justify-content: space-between;
        pointer-events: none;
      }

      #title {
        margin: 1.5rem auto 0;
        padding: 0.75rem 1.5rem;
        border-radius: 999px;
        background: rgba(7, 11, 19, 0.55);
        color: #f7fbff;
        font-size: clamp(1rem, 2vw, 1.3rem);
        letter-spacing: 0.08em;
        text-transform: uppercase;
        box-shadow: 0 1.5rem 3rem rgba(0, 0, 0, 0.35);
      }

      #cameraHint,
      #prompt {
        align-self: center;
        margin-bottom: 2rem;
        padding: 0.85rem 1.65rem;
        border-radius: 0.95rem;
        background: rgba(7, 11, 19, 0.7);
        color: #f4f7fb;
        font-size: 0.95rem;
        letter-spacing: 0.04em;
        transform: translateY(10px);
        opacity: 0;
        transition: opacity 0.2s ease, transform 0.25s ease;
      }

      #cameraHint.visible,
      #prompt.visible {
        opacity: 1;
        transform: translateY(0);
      }

      #messagePanel {
        position: fixed;
        bottom: 3rem;
        left: 50%;
        max-width: min(32rem, 90vw);
        transform: translate(-50%, 10px);
        padding: 1rem 1.5rem;
        border-radius: 1.1rem;
        background: rgba(12, 15, 24, 0.92);
        color: #f6f7fb;
        box-shadow: 0 1.5rem 3rem rgba(0, 0, 0, 0.45);
        font-size: 1.05rem;
        line-height: 1.45;
        letter-spacing: 0.015em;
        opacity: 0;
        transition: opacity 0.3s ease, transform 0.3s ease;
        pointer-events: none;
      }

      #messagePanel.visible {
        opacity: 1;
        transform: translate(-50%, 0);
      }

      #messagePanel h2 {
        margin: 0 0 0.4rem;
        font-size: 1.15rem;
        letter-spacing: 0.06em;
        text-transform: uppercase;
        color: #ffd166;
      }

      #messagePanel p {
        margin: 0;
        white-space: pre-line;
      }
    </style>
    <script type="importmap">
      {
        "imports": {
          "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
          "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
      }
    </script>
  </head>
  <body>
    <canvas id="scene"></canvas>
    <div id="ui">
      <div id="title">It's a Dog's Life &mdash; Showgrounds Prototype</div>
      <div id="cameraHint">Click to control the camera. Move the mouse to look around. Press Esc to release.</div>
      <div id="prompt"></div>
    </div>
    <div id="messagePanel">
      <h2></h2>
      <p></p>
    </div>

    <script type="module">
      import * as THREE from "three";

      const canvas = document.getElementById("scene");
      const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      renderer.shadowMap.enabled = true;

      const scene = new THREE.Scene();
      scene.background = new THREE.Color(0x7fc8f8);

      const aspect = window.innerWidth / window.innerHeight;
      const viewSize = 80;
      const camera = new THREE.OrthographicCamera(
        -viewSize * aspect,
        viewSize * aspect,
        viewSize,
        -viewSize,
        0.1,
        500
      );
      const cameraHeight = 120;
      camera.position.set(0, cameraHeight, 0);
      camera.lookAt(0, 0, 0);

      const hemi = new THREE.HemisphereLight(0xf9f9ff, 0x28432f, 0.85);
      scene.add(hemi);

      const sun = new THREE.DirectionalLight(0xffffff, 0.85);
      sun.position.set(80, 150, 60);
      sun.castShadow = true;
      sun.shadow.mapSize.set(2048, 2048);
      sun.shadow.camera.left = -150;
      sun.shadow.camera.right = 150;
      sun.shadow.camera.top = 150;
      sun.shadow.camera.bottom = -150;
      sun.shadow.camera.updateProjectionMatrix();
      scene.add(sun);

      const groundSize = 260;
      const grass = new THREE.Mesh(
        new THREE.PlaneGeometry(groundSize, groundSize),
        new THREE.MeshLambertMaterial({ color: 0x2a9134 })
      );
      grass.rotation.x = -Math.PI / 2;
      grass.receiveShadow = true;
      scene.add(grass);

      function createRect(width, depth, color, height = 0.05) {
        const mesh = new THREE.Mesh(
          new THREE.BoxGeometry(width, height, depth),
          new THREE.MeshLambertMaterial({ color })
        );
        mesh.castShadow = false;
        mesh.receiveShadow = true;
        mesh.position.y = height / 2;
        return mesh;
      }

      const pathColor = 0xd1c4a4;
      const centralCrossNorthSouth = createRect(28, 200, pathColor, 0.35);
      scene.add(centralCrossNorthSouth);

      const centralCrossEastWest = createRect(200, 28, pathColor, 0.35);
      scene.add(centralCrossEastWest);

      const courtyards = [
        { position: new THREE.Vector3(-65, 0.2, -65) },
        { position: new THREE.Vector3(65, 0.2, -65) },
        { position: new THREE.Vector3(-65, 0.2, 65) },
        { position: new THREE.Vector3(65, 0.2, 65) }
      ];

      courtyards.forEach(({ position }) => {
        const pad = createRect(60, 44, 0xd9c8a8, 0.32);
        pad.position.copy(position);
        scene.add(pad);
      });

      const northernPromenade = createRect(40, 80, 0xdac59b, 0.32);
      northernPromenade.position.set(0, 0.2, -105);
      scene.add(northernPromenade);

      const southernPromenade = createRect(40, 80, 0xdac59b, 0.32);
      southernPromenade.position.set(0, 0.2, 105);
      scene.add(southernPromenade);

      const ringBorder = new THREE.Mesh(
        new THREE.CylinderGeometry(35, 35, 1.4, 64, 1, true),
        new THREE.MeshLambertMaterial({ color: 0x3a2c1f, side: THREE.DoubleSide })
      );
      ringBorder.position.y = 0.7;
      scene.add(ringBorder);

      const ringFloor = new THREE.Mesh(
        new THREE.CircleGeometry(34, 48),
        new THREE.MeshLambertMaterial({ color: 0xd9c097 })
      );
      ringFloor.rotation.x = -Math.PI / 2;
      ringFloor.position.y = 0.05;
      ringFloor.receiveShadow = true;
      scene.add(ringFloor);

      const bleacherMaterial = new THREE.MeshLambertMaterial({ color: 0xe6e0d6 });
      for (let i = 0; i < 4; i++) {
        const bench = new THREE.Mesh(
          new THREE.BoxGeometry(12, 2, 4),
          bleacherMaterial
        );
        bench.position.set(Math.cos((i / 4) * Math.PI * 2) * 42, 1, Math.sin((i / 4) * Math.PI * 2) * 42);
        bench.rotation.y = ((i + 2) * Math.PI) / 4;
        bench.castShadow = true;
        bench.receiveShadow = true;
        scene.add(bench);
      }

      function createHouse({ color, trimColor, roofColor }) {
        const group = new THREE.Group();

        const base = new THREE.Mesh(
          new THREE.BoxGeometry(22, 16, 20),
          new THREE.MeshLambertMaterial({ color })
        );
        base.position.y = 8;
        base.castShadow = true;
        base.receiveShadow = true;
        group.add(base);

        const roof = new THREE.Mesh(
          new THREE.ConeGeometry(18, 10, 4),
          new THREE.MeshLambertMaterial({ color: roofColor })
        );
        roof.position.y = 18;
        roof.rotation.y = Math.PI / 4;
        roof.castShadow = true;
        group.add(roof);

        const door = new THREE.Mesh(
          new THREE.BoxGeometry(5, 8, 1.4),
          new THREE.MeshLambertMaterial({ color: trimColor })
        );
        door.position.set(0, 4, 10.7);
        door.castShadow = true;
        group.add(door);

        const windowGeometry = new THREE.BoxGeometry(4, 4, 1.2);
        const windowMaterial = new THREE.MeshLambertMaterial({ color: 0xf1f6ff });
        const windowPositions = [
          [-8, 6, 10.4],
          [8, 6, 10.4]
        ];
        windowPositions.forEach(([x, y, z]) => {
          const window = new THREE.Mesh(windowGeometry, windowMaterial);
          window.position.set(x, y, z);
          window.castShadow = true;
          group.add(window);
        });

        return group;
      }

      function createSign() {
        const group = new THREE.Group();

        const post = new THREE.Mesh(
          new THREE.CylinderGeometry(0.9, 1.1, 12, 12),
          new THREE.MeshLambertMaterial({ color: 0x8c5627 })
        );
        post.position.y = 6;
        post.castShadow = true;
        group.add(post);

        const plank = new THREE.Mesh(
          new THREE.BoxGeometry(9, 4.2, 1.1),
          new THREE.MeshLambertMaterial({ color: 0xfff5b5 })
        );
        plank.position.set(0, 10, 0.4);
        plank.castShadow = true;
        group.add(plank);

        return group;
      }

      const buildingPalette = [
        { color: 0xfef3c7, trimColor: 0x1d3557, roofColor: 0xb56576 },
        { color: 0xe0f2ff, trimColor: 0x264653, roofColor: 0x457b9d },
        { color: 0xfdecef, trimColor: 0x2a9d8f, roofColor: 0xe76f51 },
        { color: 0xfff4e6, trimColor: 0x6d597a, roofColor: 0xb56576 },
        { color: 0xf0fff1, trimColor: 0x355070, roofColor: 0x6d597a },
        { color: 0xe9f5db, trimColor: 0x1f3c88, roofColor: 0x577590 }
      ];

      const buildingData = [
        {
          title: "Home",
          description: "Your cozy base to rest, review scores, and plan the next showcase.",
          position: new THREE.Vector3(-60, 0, -70),
          signOffset: new THREE.Vector3(0, 0, 20)
        },
        {
          title: "Pet Store",
          description: "Pick up gourmet treats and dazzling outfits for your canine stars.",
          position: new THREE.Vector3(60, 0, -70),
          signOffset: new THREE.Vector3(0, 0, 20)
        },
        {
          title: "Veterinarian",
          description: "Routine checkups and wellness boosts keep tails wagging in the ring.",
          position: new THREE.Vector3(-70, 0, 60),
          signOffset: new THREE.Vector3(20, 0, 0)
        },
        {
          title: "Dog Groomers",
          description: "Fresh trims, shimmering coats, and bow-tie flair for every breed.",
          position: new THREE.Vector3(70, 0, 60),
          signOffset: new THREE.Vector3(-20, 0, 0)
        },
        {
          title: "Dog Club",
          description: "Trade training stories, compare ribbons, and challenge rivals to showdowns.",
          position: new THREE.Vector3(0, 0, 95),
          signOffset: new THREE.Vector3(0, 0, -20)
        },
        {
          title: "Showground",
          description: "The main arena where perfect gaits and confident poses win the judges over.",
          position: new THREE.Vector3(0, 0, 0),
          signOffset: new THREE.Vector3(-35, 0, 0),
          spawnHouse: false
        }
      ];

      const signEntries = [];

      buildingData.forEach((data, index) => {
        if (data.spawnHouse !== false) {
          const palette = buildingPalette[index % buildingPalette.length];
          const house = createHouse(palette);
          house.position.copy(data.position);
          scene.add(house);
        }

        const sign = createSign();
        sign.position.copy(data.position.clone().add(data.signOffset));
        scene.add(sign);

        signEntries.push({
          mesh: sign,
          title: data.title,
          description: data.description
        });
      });

      const welcomeSign = createSign();
      welcomeSign.position.set(0, 0, -25);
      scene.add(welcomeSign);

      signEntries.push({
        mesh: welcomeSign,
        title: "Welcome to Puppertown",
        description:
          "Population: 938 residents and 1,204 beloved pups.\nFounded: 1912 as a seasonal kennel camp that blossomed into a year-round festival village.\nClaim to fame: Hosts the Moonlight Muzzle Parade, where bioluminescent collars light up the central ring."
      });

      const shrubMaterial = new THREE.MeshLambertMaterial({ color: 0x1e6f3b });
      for (let i = 0; i < 30; i++) {
        const shrub = new THREE.Mesh(
          new THREE.SphereGeometry(THREE.MathUtils.randFloat(2, 4), 12, 12),
          shrubMaterial
        );
        const angle = THREE.MathUtils.randFloat(0, Math.PI * 2);
        const distance = THREE.MathUtils.randFloat(70, groundSize * 0.42);
        shrub.position.set(
          Math.cos(angle) * distance,
          THREE.MathUtils.randFloat(1, 3),
          Math.sin(angle) * distance
        );
        shrub.castShadow = true;
        shrub.receiveShadow = true;
        scene.add(shrub);
      }

      const handler = new THREE.Group();
      const handlerBase = new THREE.Mesh(
        new THREE.CylinderGeometry(3, 4, 4, 24),
        new THREE.MeshLambertMaterial({ color: 0xffb703 })
      );
      handlerBase.position.y = 2;
      handlerBase.castShadow = true;
      handler.add(handlerBase);

      const handlerHead = new THREE.Mesh(
        new THREE.SphereGeometry(2.5, 24, 24),
        new THREE.MeshLambertMaterial({ color: 0xf77f00 })
      );
      handlerHead.position.y = 5;
      handlerHead.castShadow = true;
      handler.add(handlerHead);

      const leash = new THREE.Mesh(
        new THREE.TorusGeometry(3.6, 0.3, 12, 32),
        new THREE.MeshLambertMaterial({ color: 0x6a4c93 })
      );
      leash.rotation.x = Math.PI / 2;
      leash.position.y = 4.1;
      handler.add(leash);

      handler.position.set(-40, 0, 40);
      scene.add(handler);

      const prompt = document.getElementById("prompt");
      const cameraHint = document.getElementById("cameraHint");
      const messagePanel = document.getElementById("messagePanel");
      const messageTitle = messagePanel.querySelector("h2");
      const messageBody = messagePanel.querySelector("p");

      let currentSign = null;
      let hideTimeout = null;

      function showPrompt(text) {
        prompt.textContent = text;
        prompt.classList.add("visible");
      }

      function hidePrompt() {
        prompt.classList.remove("visible");
        prompt.textContent = "";
      }

      function showMessage({ title, description }) {
        messageTitle.textContent = title;
        messageBody.textContent = description;
        messagePanel.classList.add("visible");
        clearTimeout(hideTimeout);
        hideTimeout = setTimeout(() => hideMessage(), 5000);
      }

      function hideMessage() {
        messagePanel.classList.remove("visible");
        messageTitle.textContent = "";
        messageBody.textContent = "";
        clearTimeout(hideTimeout);
      }

      const pressedKeys = new Set();
      const cameraState = {
        yaw: Math.PI / 4,
        radius: 90,
        height: cameraHeight
      };
      const cameraOffset = new THREE.Vector3();
      const cameraTarget = new THREE.Vector3();

      function updateCameraHint(visible) {
        if (visible) {
          cameraHint.classList.add("visible");
        } else {
          cameraHint.classList.remove("visible");
        }
      }

      updateCameraHint(true);

      canvas.addEventListener("click", () => {
        initializeAudio();
        if (document.pointerLockElement !== canvas) {
          canvas.requestPointerLock();
        }
      });

      window.addEventListener("pointerdown", initializeAudio, { once: true });

      document.addEventListener("pointerlockchange", () => {
        const locked = document.pointerLockElement === canvas;
        updateCameraHint(!locked);
      });

      document.addEventListener("mousemove", (event) => {
        if (document.pointerLockElement === canvas) {
          const sensitivity = 0.0025;
          cameraState.yaw -= event.movementX * sensitivity;
          cameraState.yaw = (cameraState.yaw + Math.PI * 2) % (Math.PI * 2);
        }
      });
      window.addEventListener("keydown", (event) => {
        initializeAudio();
        if (!event.repeat) pressedKeys.add(event.code);
        if (event.code === "Enter" && currentSign) {
          showMessage(currentSign);
        }
        if (event.code === "Escape") {
          hideMessage();
        }
      });

      window.addEventListener("keyup", (event) => {
        pressedKeys.delete(event.code);
      });

      const clock = new THREE.Clock();
      const speed = 42;
      const movementVector = new THREE.Vector3();
      const bounds = {
        minX: -groundSize * 0.48,
        maxX: groundSize * 0.48,
        minZ: -groundSize * 0.48,
        maxZ: groundSize * 0.48
      };

      const pathRects = [
        { center: new THREE.Vector2(0, 0), halfX: 14, halfZ: 100 },
        { center: new THREE.Vector2(0, 0), halfX: 100, halfZ: 14 },
        { center: new THREE.Vector2(-65, -65), halfX: 30, halfZ: 22 },
        { center: new THREE.Vector2(65, -65), halfX: 30, halfZ: 22 },
        { center: new THREE.Vector2(-65, 65), halfX: 30, halfZ: 22 },
        { center: new THREE.Vector2(65, 65), halfX: 30, halfZ: 22 },
        { center: new THREE.Vector2(0, -105), halfX: 20, halfZ: 40 },
        { center: new THREE.Vector2(0, 105), halfX: 20, halfZ: 40 }
      ];
      const ringRadiusSq = 34 * 34;

      function determineSurface(position) {
        const x = position.x;
        const z = position.z;
        const inRing = x * x + z * z <= ringRadiusSq;
        if (inRing) return "path";

        for (const rect of pathRects) {
          if (
            Math.abs(x - rect.center.x) <= rect.halfX &&
            Math.abs(z - rect.center.y) <= rect.halfZ
          ) {
            return "path";
          }
        }
        return "grass";
      }

      const backgroundMusic = new Audio(
        "https://raw.githubusercontent.com/harry0957-oss/itsadogslife/main/assets/music/mapmusic.mp3"
      );
      const grassFootsteps = new Audio(
        "https://raw.githubusercontent.com/harry0957-oss/itsadogslife/main/assets/sounds/grasswalk.mp3"
      );
      const pathFootsteps = new Audio(
        "https://raw.githubusercontent.com/harry0957-oss/itsadogslife/main/assets/sounds/pathwalk.mp3"
      );

      let audioInitialized = false;
      let activeFootsteps = null;

      function primeFootstep(audio) {
        audio.loop = true;
        audio.play().then(() => {
          audio.pause();
          audio.currentTime = 0;
        }).catch(() => {});
      }

      function initializeAudio() {
        if (audioInitialized) return;
        audioInitialized = true;

        backgroundMusic.preload = "auto";
        backgroundMusic.loop = true;
        backgroundMusic.volume = 0.2;
        backgroundMusic.play().catch(() => {});

        grassFootsteps.preload = "auto";
        grassFootsteps.volume = 0.4;
        grassFootsteps.loop = true;
        pathFootsteps.preload = "auto";
        pathFootsteps.volume = 0.5;
        pathFootsteps.loop = true;

        primeFootstep(grassFootsteps);
        primeFootstep(pathFootsteps);
      }

      function playFootsteps(surface) {
        if (!audioInitialized) return;
        const target = surface === "path" ? pathFootsteps : grassFootsteps;
        if (activeFootsteps && activeFootsteps !== target) {
          activeFootsteps.pause();
          activeFootsteps.currentTime = 0;
        }

        activeFootsteps = target;
        if (activeFootsteps.paused) {
          activeFootsteps.play().catch(() => {});
        }
      }

      function stopFootsteps() {
        if (!audioInitialized) return;
        if (activeFootsteps) {
          activeFootsteps.pause();
          activeFootsteps.currentTime = 0;
          activeFootsteps = null;
        }
      }

      function updateMovement(delta) {
        movementVector.set(0, 0, 0);
        if (pressedKeys.has("ArrowUp") || pressedKeys.has("KeyW")) movementVector.z -= 1;
        if (pressedKeys.has("ArrowDown") || pressedKeys.has("KeyS")) movementVector.z += 1;
        if (pressedKeys.has("ArrowLeft") || pressedKeys.has("KeyA")) movementVector.x -= 1;
        if (pressedKeys.has("ArrowRight") || pressedKeys.has("KeyD")) movementVector.x += 1;

        if (movementVector.lengthSq() > 0) {
          movementVector.normalize().multiplyScalar(speed * delta);
          handler.position.add(movementVector);
          handler.position.x = THREE.MathUtils.clamp(handler.position.x, bounds.minX, bounds.maxX);
          handler.position.z = THREE.MathUtils.clamp(handler.position.z, bounds.minZ, bounds.maxZ);
          handler.rotation.y = Math.atan2(movementVector.x, movementVector.z);

          const surface = determineSurface(handler.position);
          playFootsteps(surface);
        } else {
          stopFootsteps();
        }
      }

      function updateInteraction() {
        let closest = null;
        let minDistance = Infinity;
        signEntries.forEach((sign) => {
          const distance = handler.position.distanceTo(sign.mesh.position);
          if (distance < minDistance) {
            minDistance = distance;
            closest = sign;
          }
        });

        const interactDistance = 22;
        if (closest && minDistance < interactDistance) {
          currentSign = closest;
          showPrompt(`Press Enter to read the ${closest.title} sign`);
        } else {
          currentSign = null;
          hidePrompt();
        }
      }

      function animate() {
        requestAnimationFrame(animate);
        const delta = clock.getDelta();
        updateMovement(delta);
        updateInteraction();

        cameraOffset.set(
          Math.sin(cameraState.yaw) * cameraState.radius,
          cameraState.height,
          Math.cos(cameraState.yaw) * cameraState.radius
        );
        cameraTarget.copy(handler.position).add(cameraOffset);
        camera.position.lerp(cameraTarget, 0.12);
        camera.lookAt(handler.position.x, handler.position.y + 6, handler.position.z);

        renderer.render(scene, camera);
      }

      animate();

      function handleResize() {
        const aspectRatio = window.innerWidth / window.innerHeight;
        camera.left = -viewSize * aspectRatio;
        camera.right = viewSize * aspectRatio;
        camera.top = viewSize;
        camera.bottom = -viewSize;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      }

      window.addEventListener("resize", handleResize);
      handleResize();
    </script>
  </body>
</html>
