
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Town Level Designer</title>
  <style>
    :root {
      color-scheme: dark;
      font-family: "Segoe UI", system-ui, -apple-system, sans-serif;
      background-color: #0b1522;
      color: #f4f7fb;
      --tile-size: 44px;
    }

    body {
      margin: 0;
      min-height: 100vh;
      display: grid;
      grid-template-columns: 320px 1fr;
      gap: 1.5rem;
      padding: 1.5rem;
      background: radial-gradient(circle at top, rgba(100, 160, 255, 0.18), rgba(11, 21, 34, 0.95));
    }

    header {
      grid-column: 1 / -1;
      display: flex;
      flex-wrap: wrap;
      justify-content: space-between;
      align-items: center;
      gap: 1rem;
    }

    h1 {
      margin: 0;
      font-size: clamp(1.6rem, 3vw, 2.3rem);
      letter-spacing: 0.08em;
      text-transform: uppercase;
    }

    .controls {
      background: rgba(9, 18, 29, 0.85);
      border: 1px solid rgba(255, 255, 255, 0.07);
      border-radius: 1.2rem;
      padding: 1.25rem;
      display: flex;
      flex-direction: column;
      gap: 1rem;
      box-shadow: 0 1.5rem 3.5rem rgba(0, 0, 0, 0.35);
    }

    fieldset {
      border: none;
      padding: 0;
      margin: 0;
      display: grid;
      gap: 0.5rem;
    }

    legend {
      margin-bottom: 0.25rem;
      font-size: 0.95rem;
      letter-spacing: 0.06em;
      text-transform: uppercase;
      color: #9ecbff;
    }

    .tool-list {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
      gap: 0.5rem;
    }

    .brush-options {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(70px, 1fr));
      gap: 0.5rem;
    }

    button.brush {
      padding: 0.5rem 0.6rem;
      border-radius: 0.75rem;
      border: 1px solid rgba(158, 203, 255, 0.35);
      background: rgba(24, 42, 64, 0.55);
      color: inherit;
      cursor: pointer;
      font-size: 0.9rem;
      font-weight: 600;
      transition: transform 0.12s ease, background 0.12s ease, border 0.12s ease;
    }

    button.brush.active {
      background: rgba(90, 142, 255, 0.25);
      border-color: rgba(90, 142, 255, 0.9);
      box-shadow: 0 0 0 1px rgba(90, 142, 255, 0.4);
    }

    button.brush:hover {
      transform: translateY(-1px);
      background: rgba(40, 60, 90, 0.65);
    }

    .hint {
      margin: 0;
      font-size: 0.8rem;
      color: rgba(207, 227, 255, 0.7);
    }

    .sign-input {
      display: grid;
      gap: 0.35rem;
    }

    .sign-input input {
      width: 100%;
      padding: 0.4rem 0.5rem;
      border-radius: 0.5rem;
      border: 1px solid rgba(255, 255, 255, 0.15);
      background: rgba(7, 12, 20, 0.85);
      color: inherit;
    }

    button.tool {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      justify-content: center;
      padding: 0.6rem 0.75rem;
      border-radius: 0.75rem;
      border: 1px solid rgba(158, 203, 255, 0.4);
      background: rgba(24, 42, 64, 0.65);
      color: inherit;
      font-size: 0.95rem;
      cursor: pointer;
      transition: transform 0.12s ease, background 0.12s ease, border 0.12s ease;
    }

    button.tool.active {
      background: rgba(90, 142, 255, 0.25);
      border-color: rgba(90, 142, 255, 0.9);
      box-shadow: 0 0 0 1px rgba(90, 142, 255, 0.6);
    }

    button.tool:hover {
      transform: translateY(-1px);
      background: rgba(40, 60, 90, 0.7);
    }

    .tool-icon {
      font-size: 1.15rem;
    }

    .map-wrapper {
      position: relative;
      display: grid;
      gap: 1rem;
    }

    #mapCanvas {
      max-width: 100%;
      max-height: 80vh;
      background: #0a1322;
      border-radius: 1.2rem;
      padding: 1rem;
      display: grid;
      place-items: center;
      box-shadow: 0 1.5rem 3rem rgba(0, 0, 0, 0.4);
      overflow: auto;
    }

    #grid {
      display: grid;
      background: #053042;
      border-radius: 1rem;
      overflow: hidden;
      box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.05);
      gap: 2px;
      width: max-content;
      height: max-content;
    }

    .tile {
      display: grid;
      place-items: center;
      width: var(--tile-size);
      height: var(--tile-size);
      font-size: calc(var(--tile-size) * 0.45);
      font-weight: 600;
      cursor: crosshair;
      transition: background 0.1s ease, transform 0.05s ease;
      user-select: none;
      padding: 0;
      box-sizing: border-box;
    }

    .tile:hover {
      filter: brightness(1.1);
      transform: scale(1.02);
    }

    .tile[data-base="sea"] {
      background: linear-gradient(135deg, #0f3057, #0b1f36);
      color: #9ecbff;
    }

    .tile[data-base="land"] {
      background: linear-gradient(135deg, #3a5f2b, #1f3317);
      color: #f1ffe2;
    }

    .tile[data-overlay="path"] {
      background: linear-gradient(135deg, #5b4d3b, #3c3226);
      color: #fbe4c1;
    }

    .tile[data-overlay="grass"] {
      background: linear-gradient(135deg, #4d8f3a, #2f6124);
    }

    .tile[data-overlay="house"] {
      background: linear-gradient(135deg, #5c1f2f, #35101b);
    }

    .tile[data-overlay="vets"] {
      background: linear-gradient(135deg, #234c5c, #15313d);
    }

    .tile[data-overlay="dog-training"] {
      background: linear-gradient(135deg, #50396b, #2f2042);
    }

    .tile[data-overlay="dog-groomers"] {
      background: linear-gradient(135deg, #7f3b63, #4a1f38);
    }

    .tile[data-overlay="dog-show"] {
      background: linear-gradient(135deg, #73571d, #43340f);
    }

    .tile[data-overlay="pet-shop"] {
      background: linear-gradient(135deg, #2c5935, #1a3620);
    }

    .tile[data-overlay="sign"] {
      background: linear-gradient(135deg, #8a5a24, #503014);
      font-size: calc(var(--tile-size) * 0.32);
      padding: 0 0.2rem;
      text-overflow: ellipsis;
      overflow: hidden;
      white-space: nowrap;
    }

    #status {
      min-height: 2.5rem;
      font-size: 0.95rem;
      line-height: 1.45;
      color: #cfe3ff;
    }

    .export-buttons {
      display: flex;
      flex-wrap: wrap;
      gap: 0.75rem;
    }

    .primary {
      background: linear-gradient(135deg, #73a8ff, #5d7dff);
      color: #041021;
      border: none;
      font-weight: 600;
      padding: 0.75rem 1.2rem;
      border-radius: 0.85rem;
      cursor: pointer;
      box-shadow: 0 0.75rem 2rem rgba(94, 141, 255, 0.35);
      transition: transform 0.15s ease;
    }

    .primary:hover {
      transform: translateY(-1px) scale(1.01);
    }

    .secondary {
      border: 1px solid rgba(158, 203, 255, 0.4);
      background: rgba(24, 42, 64, 0.7);
      padding: 0.75rem 1.2rem;
      border-radius: 0.85rem;
      cursor: pointer;
      color: #f4f7fb;
    }

    .map-settings {
      display: grid;
      gap: 0.65rem;
    }

    label input {
      margin-left: 0.35rem;
      width: 4.5rem;
      padding: 0.3rem;
      border-radius: 0.4rem;
      border: 1px solid rgba(255, 255, 255, 0.15);
      background: rgba(7, 12, 20, 0.8);
      color: inherit;
    }

    @media (max-width: 1024px) {
      body {
        grid-template-columns: 1fr;
      }

      header {
        justify-content: center;
        text-align: center;
      }

      #mapCanvas {
        margin: 0 auto;
      }
    }
  </style>
</head>
<body>
  <header>
    <h1>Town Level Designer</h1>
    <div>
      <span>Left click to paint • Right click to sea</span>
    </div>
  </header>

  <section class="controls" aria-label="Designer Controls">
    <fieldset>
      <legend>Palette</legend>
      <div class="tool-list" id="toolList"></div>
    </fieldset>

    <fieldset>
      <legend>Brush Size</legend>
      <div class="brush-options" id="brushOptions" role="group" aria-label="Brush size options"></div>
      <p class="hint">Brush applies to Land and Grass tools (square size per side).</p>
    </fieldset>

    <fieldset class="map-settings">
      <legend>Map Settings</legend>
      <label>Grid Size: <input type="number" id="gridSize" min="6" max="50" value="16" /></label>
      <button class="secondary" id="resizeGrid">Resize Grid</button>
    </fieldset>

    <fieldset>
      <legend>Sign Writer</legend>
      <div class="sign-input">
        <label for="signText">Message</label>
        <input type="text" id="signText" maxlength="32" placeholder="Welcome adventurers" />
        <p class="hint">Update existing signs by painting them again.</p>
      </div>
    </fieldset>

    <div id="status" aria-live="polite"></div>

    <div class="export-buttons">
      <button class="secondary" id="loadJson">Load Layout JSON</button>
      <button class="primary" id="openLevel">Open Level Page</button>
      <button class="secondary" id="downloadJson">Download Layout JSON</button>
    </div>
    <input type="file" id="loadJsonInput" accept="application/json" hidden />
  </section>

  <section class="map-wrapper">
    <div id="mapCanvas">
      <div id="grid" role="grid"></div>
    </div>
  </section>

  <template id="tileTemplate">
    <button class="tile" type="button"></button>
  </template>

  <script>
    const TILE_SIZE = 44;
        const TILE_WORLD_SIZE = 32;
    const LEGEND_TEMPLATES = {
      water: { color: '#2a6f97', surface: 'water' },
      grass: { color: '#3ca66b', surface: 'grass' },
      path: { color: '#c89f5d', surface: 'path' },
      sign: { color: '#f6c177', surface: 'grass' },
      house: { color: '#f1ede0', surface: 'grass' },
      'dog-training': { color: '#f4a261', surface: 'grass' },
      'dog-groomers': { color: '#9f7aea', surface: 'grass' },
      'pet-shop': { color: '#f6ad55', surface: 'grass' },
      vets: { color: '#fc8181', surface: 'grass' },
      'dog-show': { color: '#e9d8fd', surface: 'grass' }
    };
    const BUILDING_TITLES = {
      house: 'Neighbourhood Home',
      'dog-training': 'Training Grounds',
      'dog-groomers': 'Groomers',
      'pet-shop': 'Pet Shop',
      vets: 'Veterinary Clinic'
    };
    const DEFAULT_DESCRIPTIONS = {
      house: 'A cosy place to rest.',
      'dog-training': 'Lessons for top pups await inside.',
      'dog-groomers': 'Pamper dogs with the finest trims.',
      'pet-shop': 'Stock up on treats and toys.',
      vets: 'Professional care for every pup.'
    };
    const BUILDING_OVERLAYS = new Set(['house', 'dog-training', 'dog-groomers', 'pet-shop', 'vets']);
    const BRUSH_OPTIONS = [1, 2, 4, 8];

    const palette = [
      { id: 'land', label: 'Land', icon: '🏝️', description: 'Claim land from the surrounding sea.' },
      { id: 'sea', label: 'Sea', icon: '🌊', description: 'Return a tile to open water.' },
      { id: 'grass', label: 'Grass', icon: '🌿', description: 'Add grassy terrain on land tiles.' },
      { id: 'path', label: 'Path', icon: '🪨', description: 'Lay walking paths for players.' },
      { id: 'house', label: 'House', icon: '🏠', description: 'Place village houses on land.' },
      { id: 'vets', label: 'Vets', icon: '🐾', description: 'Mark veterinary services for pets.' },
      { id: 'dog-training', label: 'Dog Training', icon: '🎯', description: 'Plan dedicated dog training areas.' },
      { id: 'dog-groomers', label: 'Dog Groomers', icon: '✂️', description: 'Set up grooming parlours for pups.' },
      { id: 'dog-show', label: 'Dog Show', icon: '🏆', description: 'Designate the show arena.' },
      { id: 'pet-shop', label: 'Pet Shop', icon: '🛍️', description: 'Place pet supply stores.' },
      { id: 'sign', label: 'Sign', icon: '🪧', description: 'Add signage for directions or lore.' }
    ];

    const overlayEmoji = {
      none: '',
      grass: '🌿',
      path: '🪨',
      house: '🏠',
      vets: '🐾',
      'dog-training': '🎯',
      'dog-groomers': '✂️',
      'dog-show': '🏆',
      'pet-shop': '🛍️',
      sign: '🪧'
    };

    const landOnlyTools = new Set(['grass', 'path', 'house', 'vets', 'dog-training', 'dog-groomers', 'dog-show', 'pet-shop', 'sign']);
    const buildingTools = new Set(['house', 'vets', 'dog-training', 'dog-groomers', 'dog-show', 'pet-shop']);

    let currentTool = 'land';
    let gridSize = 16;
    let mouseDown = false;
    let brushDimension = 1;
    let currentSignText = '';

    const gridElement = document.getElementById('grid');
    const statusElement = document.getElementById('status');

    const tileTemplate = document.getElementById('tileTemplate');
    const brushContainer = document.getElementById('brushOptions');
    const signInput = document.getElementById('signText');

    const baseTypes = new Set(['sea', 'land']);
    const overlayTypes = new Set([
      'none',
      'grass',
      'path',
      'house',
      'vets',
      'dog-training',
      'dog-groomers',
      'dog-show',
      'pet-shop',
      'sign'
    ]);

    const state = [];
    const tileElements = [];

    signInput.addEventListener('input', event => {
      currentSignText = event.target.value.trim();
    });

    function initPalette() {
      const toolList = document.getElementById('toolList');
      palette.forEach(tool => {
        const button = document.createElement('button');
        button.type = 'button';
        button.className = 'tool';
        button.dataset.tool = tool.id;
        button.innerHTML = `<span class="tool-icon">${tool.icon}</span> ${tool.label}`;
        button.title = tool.description;
        if (tool.id === currentTool) button.classList.add('active');
        button.addEventListener('click', () => {
          currentTool = tool.id;
          toolList.querySelectorAll('.tool').forEach(btn => btn.classList.toggle('active', btn === button));
          updateStatus(`Selected ${tool.label}. ${tool.description}`);
        });
        toolList.appendChild(button);
      });
    }

    function initBrushOptions() {
      BRUSH_OPTIONS.forEach(size => {
        const button = document.createElement('button');
        button.type = 'button';
        button.className = 'brush';
        button.dataset.size = size;
        button.textContent = `${size}×${size}`;
        if (size === brushDimension) button.classList.add('active');
        button.addEventListener('click', () => {
          brushDimension = size;
          brushContainer.querySelectorAll('.brush').forEach(btn => btn.classList.toggle('active', btn === button));
          updateStatus(`Brush size set to ${size}×${size} tiles for Land and Grass.`);
        });
        brushContainer.appendChild(button);
      });
    }

    function createState(size) {
      state.length = 0;
      for (let y = 0; y < size; y++) {
        const row = [];
        for (let x = 0; x < size; x++) {
          row.push({ base: 'sea', overlay: 'none', signText: '' });
        }
        state.push(row);
      }
    }

    function renderGrid() {
      gridElement.innerHTML = '';
      gridElement.style.setProperty('--tile-size', `${TILE_SIZE}px`);
      gridElement.style.gridTemplateColumns = `repeat(${gridSize}, ${TILE_SIZE}px)`;
      gridElement.style.gridTemplateRows = `repeat(${gridSize}, ${TILE_SIZE}px)`;
      gridElement.style.width = `${gridSize * TILE_SIZE}px`;
      gridElement.style.height = `${gridSize * TILE_SIZE}px`;
      tileElements.length = 0;

      for (let y = 0; y < gridSize; y++) {
        tileElements[y] = [];
        for (let x = 0; x < gridSize; x++) {
          const tileState = state[y][x];
          const tile = tileTemplate.content.firstElementChild.cloneNode(true);
          tile.dataset.x = x;
          tile.dataset.y = y;
          updateTileAppearance(tile, tileState);
          tile.addEventListener('pointerdown', handlePointerDown);
          tile.addEventListener('pointerenter', handlePointerEnter);
          tile.addEventListener('contextmenu', event => event.preventDefault());
          tileElements[y][x] = tile;
          gridElement.appendChild(tile);
        }
      }
    }

    function updateTileAppearance(tile, tileState) {
      tile.dataset.base = tileState.base;
      tile.dataset.overlay = tileState.overlay;
      if (tileState.signText) {
        tile.dataset.signText = tileState.signText;
      } else {
        delete tile.dataset.signText;
      }
      tile.title = tileState.overlay === 'sign' && tileState.signText ? tileState.signText : '';
      if (tileState.overlay === 'sign') {
        tile.textContent = tileState.signText || overlayEmoji.sign;
      } else {
        tile.textContent = overlayEmoji[tileState.overlay] || '';
      }
      const overlayLabel =
        tileState.overlay === 'none'
          ? ''
          : tileState.overlay === 'sign'
            ? (tileState.signText ? ` with sign “${tileState.signText}”` : ' with sign')
            : ` with ${tileState.overlay.replace(/-/g, ' ')}`;
      tile.setAttribute('aria-label', `${tileState.base} tile${overlayLabel}`);
    }

    function applyTool(x, y, tool = currentTool) {
      const tile = state[y][x];
      switch (tool) {
        case 'sea': {
          const changed = tile.base !== 'sea' || tile.overlay !== 'none' || tile.signText !== '';
          tile.base = 'sea';
          tile.overlay = 'none';
          tile.signText = '';
          return changed;
        }
        case 'land': {
          const changed = tile.base !== 'land';
          tile.base = 'land';
          return changed;
        }
        case 'grass':
        case 'path': {
          if (tile.base !== 'land') return false;
          if (tile.overlay === tool) return false;
          tile.overlay = tool;
          tile.signText = '';
          return true;
        }
        case 'sign': {
          if (tile.base !== 'land') return false;
          const text = currentSignText;
          if (tile.overlay === 'sign' && tile.signText === text) return false;
          tile.overlay = 'sign';
          tile.signText = text;
          return true;
        }
        default: {
          if (buildingTools.has(tool)) {
            if (tile.base !== 'land') return false;
            if (tile.overlay === tool) return false;
            tile.overlay = tool;
            tile.signText = '';
            return true;
          }
        }
      }
      return false;
    }

    function applyBrush(x, y, tool) {
      const span = tool === 'land' || tool === 'grass' ? Math.min(brushDimension, gridSize) : 1;
      const startX = Math.max(0, Math.min(x, gridSize - span));
      const startY = Math.max(0, Math.min(y, gridSize - span));
      let needsLand = false;

      for (let by = 0; by < span; by++) {
        for (let bx = 0; bx < span; bx++) {
          const nx = startX + bx;
          const ny = startY + by;
          const tileState = state[ny][nx];
          if (landOnlyTools.has(tool) && tileState.base !== 'land') {
            needsLand = true;
            continue;
          }
          if (applyTool(nx, ny, tool)) {
            const row = tileElements[ny];
            if (row) {
              const tile = row[nx];
              if (tile) {
                updateTileAppearance(tile, state[ny][nx]);
              }
            }
          }
        }
      }

      if (needsLand) {
        updateStatus('Claim land before placing terrain, buildings, or signs.');
      }
    }

    function handlePointerDown(event) {
      event.preventDefault();
      const tool = event.button === 2 ? 'sea' : currentTool;
      const x = Number(event.currentTarget.dataset.x);
      const y = Number(event.currentTarget.dataset.y);
      mouseDown = true;
      applyBrush(x, y, tool);
      window.addEventListener('pointerup', handlePointerUp, { once: true });
    }

    function handlePointerEnter(event) {
      if (!mouseDown) return;
      const tool = event.buttons === 2 ? 'sea' : currentTool;
      const x = Number(event.currentTarget.dataset.x);
      const y = Number(event.currentTarget.dataset.y);
      applyBrush(x, y, tool);
    }

    function handlePointerUp() {
      mouseDown = false;
    }

    function updateStatus(message) {
      statusElement.textContent = message;
    }

    function resizeGrid() {
      const requested = Number(document.getElementById('gridSize').value);
      if (!Number.isInteger(requested) || requested < 6 || requested > 50) {
        updateStatus('Grid size must be between 6 and 50.');
        return;
      }
      gridSize = requested;
      createState(gridSize);
      renderGrid();
      updateStatus(`Grid resized to ${gridSize} × ${gridSize}. Start shaping your land!`);
    }

   function cloneTiles() {
      return state.map((row) => row.map((tile) => ({
        base: tile.base,
        overlay: tile.overlay,
        signText: tile.signText
      })));
    }

    function legendKeyForTile(tile) {
      if (tile.base === 'sea') return 'water';
      if (tile.overlay === 'path') return 'path';
      if (tile.overlay && tile.overlay !== 'none' && tile.overlay !== 'grass') return tile.overlay;
      return 'grass';
    }

    function toTitleCase(value) {
      return value.replace(/-/g, ' ').replace(/\b\w/g, (char) => char.toUpperCase());
    }

    function createLevelDefinition() {
      const tiles = cloneTiles();
      const signTiles = [];
      for (let y = 0; y < gridSize; y++) {
        for (let x = 0; x < gridSize; x++) {
          const tile = tiles[y][x];
          if (tile.overlay === 'sign') {
            signTiles.push({ x, y, text: tile.signText.trim(), used: false });
          }
        }
      }

      function findNearestSign(x, y) {
        let candidate = null;
        let minDistance = Infinity;
        for (const sign of signTiles) {
          if (sign.used || !sign.text) continue;
          const distance = Math.abs(sign.x - x) + Math.abs(sign.y - y);
          if (distance < minDistance) {
            minDistance = distance;
            candidate = sign;
          }
        }
        if (candidate && minDistance <= 3) {
          candidate.used = true;
          return candidate;
        }
        return null;
      }

      function computeSignOffset(from, to) {
        const dx = to.x - from.x;
        const dz = from.y - to.y;
        return [dx * TILE_WORLD_SIZE, 0, dz * TILE_WORLD_SIZE];
      }

      const usedLegendKeys = new Set();
      const grid = [];
      const buildings = [];
      const showTiles = [];
      let spawn = null;

      for (let y = 0; y < gridSize; y++) {
        const row = [];
        for (let x = 0; x < gridSize; x++) {
          const tile = tiles[y][x];
          let key = legendKeyForTile(tile);
          if (!(key in LEGEND_TEMPLATES)) {
            key = 'grass';
          }
          row.push(key);
          usedLegendKeys.add(key);

          if (tile.overlay === 'dog-show') {
            showTiles.push({ x, y });
          }

          if (BUILDING_OVERLAYS.has(tile.overlay)) {
            const sign = findNearestSign(x, y);
            const title = BUILDING_TITLES[tile.overlay] || toTitleCase(tile.overlay);
            const description = sign?.text || DEFAULT_DESCRIPTIONS[tile.overlay] || '';
            const building = { tile: [x, y], title, description };
            if (sign) {
              building.signOffset = computeSignOffset({ x, y }, sign);
            }

            if (tile.overlay === 'house' && !spawn) {
              const offsets = [
                [1, 0],
                [-1, 0],
                [0, 1],
                [0, -1]
              ];
              for (const [dx, dy] of offsets) {
                const nx = x + dx;
                const ny = y + dy;
                if (nx < 0 || nx >= gridSize || ny < 0 || ny >= gridSize) continue;
                if (tiles[ny][nx].overlay === 'path') {
                  spawn = { tile: [nx, ny] };
                  break;
                }
              }
              if (!spawn) {
                spawn = { tile: [x, y] };
              }
            }

            buildings.push(building);
          }
        }
        grid.push(row);
      }

      if (!spawn) {
        outer: for (let y = Math.floor(gridSize / 2); y < gridSize; y++) {
          for (let x = Math.floor(gridSize / 2); x < gridSize; x++) {
            if (tiles[y][x].overlay === 'path') {
              spawn = { tile: [x, y] };
              break outer;
            }
          }
        }
      }

      if (!spawn) {
        spawn = { tile: [Math.floor(gridSize / 2), Math.floor(gridSize / 2)] };
      }

      const extraSigns = signTiles
        .filter((sign) => !sign.used && sign.text)
        .map((sign) => ({
          tile: [sign.x, sign.y],
          title: sign.text,
          description: sign.text
        }));

      let showring = null;
      if (showTiles.length) {
        const avgX = showTiles.reduce((sum, pos) => sum + pos.x, 0) / showTiles.length;
        const avgY = showTiles.reduce((sum, pos) => sum + pos.y, 0) / showTiles.length;
        showring = {
          tile: [Math.round(avgX), Math.round(avgY)],
          radius: 18,
          floorRadius: 15,
          height: 1.6
        };
      }

      const legend = {};
      usedLegendKeys.forEach((key) => {
        legend[key] = LEGEND_TEMPLATES[key];
      });

      return {
        name: 'Custom Layout',
        width: gridSize,
        height: gridSize,
        tileWorldSize: TILE_WORLD_SIZE,
        legend,
        layers: [
          {
            name: 'ground',
            grid
          }
        ],
        tilesets: {},
        objects: {
          spawn,
          buildings,
          extraSigns,
          showring
        },
        size: gridSize,
        tiles
      };
    }

    function exportJson() {
      const layout = createLevelDefinition();
      const blob = new Blob([JSON.stringify(layout, null, 2)], { type: 'application/json' });
      const link = document.createElement('a');
      link.href = URL.createObjectURL(blob);
      link.download = 'town-layout.json';
      link.click();
      URL.revokeObjectURL(link.href);
    }

    function loadJsonFromFile(file) {
      const reader = new FileReader();
      reader.addEventListener('load', () => {
        try {
          const parsed = JSON.parse(reader.result);
          applyLayout(parsed);
          updateStatus(`Loaded layout from ${file.name}.`);
        } catch (error) {
          console.error('Failed to load layout', error);
          const message = error instanceof Error ? error.message : 'Invalid JSON file.';
          updateStatus(`Unable to load layout: ${message}`);
        }
      });
      reader.readAsText(file);
    }

    function applyLayout(layout) {
      if (!layout || typeof layout !== 'object') {
        throw new Error('Layout must be an object.');
      }
            const fallbackDimension =
        typeof layout.width === 'number' && Number.isFinite(layout.width)
          ? layout.width
          : layout.height;
      const size = Number(layout.size ?? fallbackDimension);
      if (!Number.isInteger(size) || size < 6 || size > 50) {
        throw new Error('Layout size out of bounds.');
      }
      const tiles = layout.tiles;
      if (!Array.isArray(tiles) || tiles.length !== size) {
        throw new Error('Tiles array does not match layout size.');
      }

      gridSize = size;
      createState(gridSize);

      for (let y = 0; y < gridSize; y++) {
        const row = tiles[y];
        if (!Array.isArray(row) || row.length !== gridSize) {
          throw new Error('Tile rows must match layout size.');
        }
        for (let x = 0; x < gridSize; x++) {
          state[y][x] = sanitizeTile(row[x]);
        }
      }

      document.getElementById('gridSize').value = gridSize;
      renderGrid();
      mouseDown = false;
    }

    function sanitizeTile(tile) {
      const safeBase = baseTypes.has(tile?.base) ? tile.base : 'sea';
      let safeOverlay = overlayTypes.has(tile?.overlay) ? tile.overlay : 'none';
      let safeSign = '';

      if (safeOverlay !== 'none' && safeBase !== 'land') {
        safeOverlay = 'none';
      }

      if (safeOverlay === 'sign') {
        safeSign = typeof tile?.signText === 'string' ? tile.signText.slice(0, 32).trim() : '';
      }

      return {
        base: safeOverlay === 'none' ? safeBase : 'land',
        overlay: safeOverlay,
        signText: safeSign
      };
    }

    function openLevelPage() {
      const levelHtml = generateLevelHtml();
      const levelWindow = window.open('', '_blank');
      if (!levelWindow) {
        updateStatus('Pop-up blocked. Allow pop-ups to open the level page.');
        return;
      }
      levelWindow.document.write(levelHtml);
      levelWindow.document.close();
    }

    function generateLevelHtml() {
      const tileSize = Math.max(Math.min(TILE_SIZE, Math.floor(600 / Math.max(gridSize, 1))), 24);
      const signFont = Math.max(Math.floor(tileSize * 0.35), 10);
      const mapRows = state
        .map((row, y) => {
          const cells = row
            .map((tile, x) => {
              const classes = [`base-${tile.base}`];
              if (tile.overlay !== 'none') classes.push(`overlay-${tile.overlay}`);
              const overlayLabel =
                tile.overlay === 'none'
                  ? ''
                  : tile.overlay === 'sign'
                    ? (tile.signText ? ` with sign "${tile.signText}"` : ' with sign')
                    : ` with ${tile.overlay.replace(/-/g, ' ')}`;
              const ariaLabel = `${tile.base} tile${overlayLabel}`;
              const content =
                tile.overlay === 'sign'
                  ? `<span class="sign-text" style="font-size:${signFont}px">${tile.signText ? escapeHtml(tile.signText) : '🪧'}</span>`
                  : `${overlayEmoji[tile.overlay] || ''}`;
              return `<div class="cell ${classes.join(' ')}" data-x="${x}" data-y="${y}" aria-label="${escapeHtml(ariaLabel)}">${content}</div>`;
            })
            .join('');
          return `<div class="row">${cells}</div>`;
        })
        .join('');

      return `<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Town Level Preview</title>
  <style>
    :root { color-scheme: dark; }
    body {
      margin: 0;
      min-height: 100vh;
      display: grid;
      place-items: center;
      background: radial-gradient(circle at top, rgba(120, 180, 255, 0.18), rgba(9, 14, 24, 0.95));
      font-family: "Segoe UI", system-ui, sans-serif;
      color: #eef5ff;
    }
    h1 { margin-bottom: 1rem; letter-spacing: 0.08em; text-transform: uppercase; }
    .map {
      display: grid;
      grid-template-rows: repeat(${gridSize}, ${tileSize}px);
      grid-template-columns: repeat(${gridSize}, ${tileSize}px);
      background: #041422;
      padding: 0.75rem;
      border-radius: 1.2rem;
      box-shadow: 0 1.5rem 3.5rem rgba(0, 0, 0, 0.4);
      gap: 2px;
    }
    .cell {
      display: grid;
      place-items: center;
      font-size: ${Math.max(Math.floor(tileSize * 0.55), 12)}px;
      border-radius: 0.35rem;
    }
    .base-sea { background: linear-gradient(135deg, #0d3357, #051729); color: #8fbefc; }
    .base-land { background: linear-gradient(135deg, #375126, #1c2c15); color: #f1ffd8; }
    .base-land.overlay-path { background: linear-gradient(135deg, #5d4a39, #31261c); }
    .base-land.overlay-grass { background: linear-gradient(135deg, #4d8f3a, #2f6124); }
    .base-land.overlay-house { background: linear-gradient(135deg, #5c1f2f, #35101b); }
    .base-land.overlay-vets { background: linear-gradient(135deg, #234c5c, #15313d); }
    .base-land.overlay-dog-training { background: linear-gradient(135deg, #50396b, #2f2042); }
    .base-land.overlay-dog-groomers { background: linear-gradient(135deg, #7f3b63, #4a1f38); }
    .base-land.overlay-dog-show { background: linear-gradient(135deg, #73571d, #43340f); }
    .base-land.overlay-pet-shop { background: linear-gradient(135deg, #2c5935, #1a3620); }
    .base-land.overlay-sign { background: linear-gradient(135deg, #8a5a24, #503014); color: #ffe9c4; }
    .overlay-sign .sign-text {
      font-weight: 600;
      letter-spacing: 0.05em;
      text-align: center;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      padding: 0 0.2rem;
    }
    footer { margin-top: 1.5rem; font-size: 0.9rem; color: rgba(238, 245, 255, 0.7); }
  </style>
</head>
<body>
  <main>
    <h1>Town Level Preview</h1>
    <section class="map" role="grid" aria-label="Town layout">
      ${mapRows}
    </section>
    <footer>Everything beyond the island edge is open sea and currently inaccessible.</footer>
  </main>
</body>
</html>`;
    }

    function escapeHtml(value) {
      return String(value ?? '')
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#39;');
    }

    document.getElementById('resizeGrid').addEventListener('click', resizeGrid);
    document.getElementById('downloadJson').addEventListener('click', exportJson);
    document.getElementById('loadJson').addEventListener('click', () => {
      document.getElementById('loadJsonInput').click();
    });
    document.getElementById('loadJsonInput').addEventListener('change', event => {
      const [file] = event.target.files || [];
      if (!file) return;
      const isJsonType = file.type === 'application/json';
      const isJsonName = file.name?.toLowerCase().endsWith('.json');
      if (file.type && !isJsonType && !isJsonName) {
        updateStatus('Please choose a JSON layout file.');
        event.target.value = '';
        return;
      }
      loadJsonFromFile(file);
      event.target.value = '';
    });
    document.getElementById('openLevel').addEventListener('click', openLevelPage);
    gridElement.addEventListener('pointerleave', () => (mouseDown = false));

    initPalette();
    initBrushOptions();
    currentSignText = signInput.value.trim();
    createState(gridSize);
    renderGrid();
    updateStatus('Select Land to shape your island, use Grass with larger brushes to fill areas, then add paths, specialist buildings, and custom signs. Right-click turns tiles back into sea.');
  </script>
</body>
</html>
